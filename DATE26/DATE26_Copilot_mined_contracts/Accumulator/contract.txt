ASSUMES 
A1:  (rst_n = 0) || (rst_n = 1);
A2:  (valid_in = 0) || (valid_in = 1);
A3:  0 <= data_in && data_in <= 127;


GUARANTEES

-- Reset behavior
G0:  G ( !(rst_n = 1) -> (data_out = 0 && !(valid_out = 1)) );

-- First post-reset update initializes the running sum
G1:  G ( !(rst_n = 1) -> X( data_out == valid_in * data_in ) );

-- Accumulator update law (one-cycle latency)
G2:  G ( (rst_n = 1) && !(valid_out = 1) -> X(data_out) == data_out + valid_in * data_in );
G3:  G ( (rst_n = 1) &&  (valid_out = 1) -> X(data_out) == valid_in * data_in );

-- Commit strobe periodicity: one-cycle pulse every 4 cycles while out of reset
G4:  G ( (rst_n = 1) && (valid_out = 1) ->
           (  X( !(valid_out = 1) ) && X( X( !(valid_out = 1) ) ) && X( X( X( !(valid_out = 1) ) ) ) && X( X( X( X( (valid_out = 1) ) ) ) ) ) );

-- Initialize the 4-cycle rhythm immediately after reset deassertion
G4p: G ( !(rst_n = 1) && X(rst_n = 1) ->
           (  X( !(valid_out = 1) )
           && X( X( !(valid_out = 1) ) )
           && X( X( X( !(valid_out = 1) ) ) )
           && X( X( X( X( (valid_out = 1) ) ) ) ) ) );

-- Functional meaning of a commit:
-- On a commit cycle, data_out equals the sum of the previous four gated inputs
G5:  G ( (rst_n = 1) && X( X( X( X( (valid_out = 1) ) ) ) ) -> X( X( X( X(data_out = (valid_in * data_in) + X( valid_in * data_in ) + X( X( valid_in * data_in ) ) + X( X( X( valid_in * data_in ) ) )) ) ) ) );



IDEAL:  
      G({rst_n} |-> {##[1:4] valid_out}) 
      G({valid_in} |-> {##[1:4] valid_out})