// /////////////////////////////////////////////////////////////////////////
// C++ code automatically generated by hif2sc
// Part of HIFSuite - Version 
// Site: www.hifsuite.com - Contact: hifsuite@edalab.it
//
// HIFSuite copyright: EDALab s.r.l. - Networked Embedded Systems
// Site: www.edalab.it - Contact: info@edalab.it
// /////////////////////////////////////////////////////////////////////////


#include "../inc/sqrt_newton.hpp"



sqrt_newton::sqrt_newton() :
    hif_fault_node(muffin::hif_next_instance_counter(), 166ULL),
    x_old(0L),
    start_old(false),
    rst_old(false),
    clk_old(false),
    hif_a2t_data(
    false,
    false,
    false,
    int32_t(0L),
    uint32_t(0UL),
    false,
    false),
    xn(0UL),
    iter(uint8_t(0U)),
    running(false),
    xn_new(0UL),
    iter_new(uint8_t(0U)),
    running_new(false),
    process_in_queue(false),
    flag_process_executed(false),
    flag_pos_clk(false),
    flag_pos_rst(false)
{
    if (hif_fault_list_root != nullptr)
    {
        hif_fault_list_root->prev = &hif_fault_node;
        hif_fault_node.next = hif_fault_list_root;
    }
    hif_fault_list_root = &hif_fault_node;
}


sqrt_newton::~sqrt_newton()
{}


void sqrt_newton::process()
{
    if (hif_a2t_data.rst)
    {
        hif_a2t_data.y = muffin::inject_renamed_4( hif_fault_node.instance, 0ULL,
                 32ULL, uint32_t(0UL) );
        hif_a2t_data.done = muffin::inject( hif_fault_node.instance, 32ULL, 1ULL,
                 false );
        hif_a2t_data.error = muffin::inject( hif_fault_node.instance, 33ULL, 1ULL,
                 false );
        running_new = muffin::inject( hif_fault_node.instance, 34ULL, 1ULL, false
             );
        iter_new = muffin::inject_renamed_2( hif_fault_node.instance, 35ULL, 8ULL,
                 uint8_t(0U) );
    }
    else if (muffin::inject( hif_fault_node.instance, 43ULL, 1ULL, !running && hif_a2t_data.start
         ))
    {
        if (muffin::inject( hif_fault_node.instance, 44ULL, 1ULL, hif_a2t_data.x
                 < 0L ))
        {
            hif_a2t_data.error = muffin::inject( hif_fault_node.instance, 45ULL,
                     1ULL, true );
            hif_a2t_data.done = muffin::inject( hif_fault_node.instance, 46ULL,
                     1ULL, true );
            running_new = muffin::inject( hif_fault_node.instance, 47ULL, 1ULL,
                     false );
        }
        else
        {
            xn_new = muffin::inject_renamed_4( hif_fault_node.instance, 48ULL, 32ULL,
                     static_cast< uint32_t >( hif_a2t_data.x ) >> uint32_t(1UL)
                 );
            iter_new = muffin::inject_renamed_2( hif_fault_node.instance, 80ULL,
                     8ULL, uint8_t(0U) );
            hif_a2t_data.done = muffin::inject( hif_fault_node.instance, 88ULL,
                     1ULL, false );
            hif_a2t_data.error = muffin::inject( hif_fault_node.instance, 89ULL,
                     1ULL, false );
            running_new = muffin::inject( hif_fault_node.instance, 90ULL, 1ULL,
                     true );
        }
    }
    else if (running)
    {
        xn_new = muffin::inject_renamed_4( hif_fault_node.instance, 91ULL, 32ULL,
                 hif_a2t_data.x / xn + xn >> uint32_t(1UL) );
        iter_new = muffin::inject_renamed_2( hif_fault_node.instance, 123ULL, 8ULL,
                 static_cast< uint8_t >( static_cast< uint8_t >( iter & uint8_t
                (15U) ) + uint8_t(1U) ) );
        if (muffin::inject( hif_fault_node.instance, 131ULL, 1ULL, static_cast<
                 uint8_t >( iter & uint8_t(15U) ) == uint8_t(9U) ))
        {
            hif_a2t_data.y = muffin::inject_renamed_4( hif_fault_node.instance,
                     132ULL, 32ULL, xn );
            hif_a2t_data.done = muffin::inject( hif_fault_node.instance, 164ULL,
                     1ULL, true );
            running_new = muffin::inject( hif_fault_node.instance, 165ULL, 1ULL,
                     false );
        }
    }
}


void sqrt_newton::update_input_queue( bool synch_phase )
{
    process_in_queue = false;
    if (hif_a2t_data.clk != clk_old)
    {
        clk_old = hif_a2t_data.clk;
        if (hif_a2t_data.clk == true)
        {
            flag_pos_clk = true;
        }
        else
        {
            flag_pos_clk = false;
        }
        process_in_queue = true;
    }
    else
    {
        flag_pos_clk = false;
    }
    if (hif_a2t_data.rst != rst_old)
    {
        rst_old = hif_a2t_data.rst;
        if (hif_a2t_data.rst == true)
        {
            flag_pos_rst = true;
        }
        else
        {
            flag_pos_rst = false;
        }
        process_in_queue = true;
    }
    else
    {
        flag_pos_rst = false;
    }
    start_old = hif_a2t_data.start;
    x_old = hif_a2t_data.x;
}


void sqrt_newton::update_event_queue()
{
    process_in_queue = false;
    iter = iter_new;
    running = running_new;
    xn = xn_new;
}


void sqrt_newton::flag_elaboration()
{
    flag_process_executed = false;
    if (flag_pos_clk || flag_pos_rst)
    {
        process();
        flag_process_executed = true;
    }
}


void sqrt_newton::synch_elaboration()
{
    update_input_queue( true );
    flag_elaboration();
    flag_pos_clk = false;
    flag_pos_rst = false;
    update_event_queue();
}


void sqrt_newton::simulate( sqrt_newton_iostruct * io_exchange, int32_t & cycles_number
     )
{
    hif_a2t_data.clk = io_exchange->clk;
    hif_a2t_data.rst = io_exchange->rst;
    hif_a2t_data.start = io_exchange->start;
    hif_a2t_data.x = io_exchange->x;
    cycles_number = cycles_number + 1L;
    synch_elaboration();
    while (process_in_queue)
    {
        flag_elaboration();
        update_event_queue();
    }
    io_exchange->y = hif_a2t_data.y;
    io_exchange->done = hif_a2t_data.done;
    io_exchange->error = hif_a2t_data.error;
}


void sqrt_newton::start_of_simulation()
{
    process();
    flag_process_executed = true;
    update_event_queue();
}


void sqrt_newton::initialize()
{
    start_of_simulation();
}


void sqrt_newton::finalize()
{
}




