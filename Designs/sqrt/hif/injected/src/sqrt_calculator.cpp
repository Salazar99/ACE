// /////////////////////////////////////////////////////////////////////////
// C++ code automatically generated by hif2sc
// Part of HIFSuite - Version 
// Site: www.hifsuite.com - Contact: hifsuite@edalab.it
//
// HIFSuite copyright: EDALab s.r.l. - Networked Embedded Systems
// Site: www.edalab.it - Contact: info@edalab.it
// /////////////////////////////////////////////////////////////////////////


#include "../inc/sqrt_calculator.hpp"



sqrt_calculator::sqrt_calculator() :
    hif_fault_node(muffin::hif_next_instance_counter(), 121ULL),
    in_old(uint16_t(0U)),
    start_old(false),
    rst_old(false),
    clk_old(false),
    hif_a2t_data(
    false,
    false,
    false,
    uint16_t(0U),
    uint8_t(0U),
    false,
    false),
    num(uint16_t(0U)),
    guess(uint8_t(0U)),
    iter(uint8_t(0U)),
    num_new(uint16_t(0U)),
    guess_new(uint8_t(0U)),
    iter_new(uint8_t(0U)),
    process_in_queue(false),
    flag_process_executed(false),
    flag_pos_clk(false),
    flag_pos_rst(false)
{
    if (hif_fault_list_root != nullptr)
    {
        hif_fault_list_root->prev = &hif_fault_node;
        hif_fault_node.next = hif_fault_list_root;
    }
    hif_fault_list_root = &hif_fault_node;
}


sqrt_calculator::~sqrt_calculator()
{}


void sqrt_calculator::process()
{
    if (hif_a2t_data.rst)
    {
        hif_a2t_data.out = muffin::inject_renamed_2( hif_fault_node.instance, 0ULL,
                 8ULL, uint8_t(0U) );
        hif_a2t_data.error = muffin::inject( hif_fault_node.instance, 8ULL, 1ULL,
                 false );
        hif_a2t_data.done = muffin::inject( hif_fault_node.instance, 9ULL, 1ULL,
                 false );
        num_new = muffin::inject_renamed_3( hif_fault_node.instance, 10ULL, 16ULL,
                 uint16_t(0U) );
        guess_new = muffin::inject_renamed_2( hif_fault_node.instance, 26ULL, 8ULL,
                 uint8_t(0U) );
        iter_new = muffin::inject_renamed_2( hif_fault_node.instance, 34ULL, 8ULL,
                 uint8_t(0U) );
    }
    else if (hif_a2t_data.start)
    {
        if (muffin::inject_renamed_3( hif_fault_node.instance, 42ULL, 16ULL, static_cast<
                 uint16_t >( static_cast< uint16_t >( hif_a2t_data.in >> uint16_t
                (15U) ) & uint16_t(1U) ) ))
        {
            hif_a2t_data.error = muffin::inject( hif_fault_node.instance, 58ULL,
                     1ULL, true );
            hif_a2t_data.done = muffin::inject( hif_fault_node.instance, 59ULL,
                     1ULL, true );
        }
        else
        {
            num_new = muffin::inject_renamed_3( hif_fault_node.instance, 60ULL,
                     16ULL, hif_a2t_data.in );
            guess_new = muffin::inject_renamed_2( hif_fault_node.instance, 76ULL,
                     8ULL, uint8_t(1U) );
            iter_new = muffin::inject_renamed_2( hif_fault_node.instance, 84ULL,
                     8ULL, uint8_t(0U) );
            hif_a2t_data.error = muffin::inject( hif_fault_node.instance, 92ULL,
                     1ULL, false );
            hif_a2t_data.done = muffin::inject( hif_fault_node.instance, 93ULL,
                     1ULL, false );
        }
    }
    else if (muffin::inject( hif_fault_node.instance, 94ULL, 1ULL, !hif_a2t_data.done
         ))
    {
        if (muffin::inject( hif_fault_node.instance, 95ULL, 1ULL, static_cast< uint8_t
                 >( iter & uint8_t(15U) ) < uint8_t(10U) ))
        {
            guess_new = muffin::inject_renamed_2( hif_fault_node.instance, 96ULL,
                     8ULL, static_cast< uint8_t >( static_cast< uint32_t >( static_cast<
                     uint16_t >( static_cast< uint16_t >( num / guess ) + static_cast<
                     uint16_t >( guess ) ) ) >> 1UL ) );
            iter_new = muffin::inject_renamed_2( hif_fault_node.instance, 104ULL,
                     8ULL, static_cast< uint8_t >( static_cast< uint8_t >( iter
                     & uint8_t(15U) ) + uint8_t(1U) ) );
        }
        else
        {
            hif_a2t_data.out = muffin::inject_renamed_2( hif_fault_node.instance,
                     112ULL, 8ULL, guess );
            hif_a2t_data.done = muffin::inject( hif_fault_node.instance, 120ULL,
                     1ULL, true );
        }
    }
}


void sqrt_calculator::update_input_queue( bool synch_phase )
{
    process_in_queue = false;
    if (hif_a2t_data.clk != clk_old)
    {
        clk_old = hif_a2t_data.clk;
        if (hif_a2t_data.clk == true)
        {
            flag_pos_clk = true;
        }
        else
        {
            flag_pos_clk = false;
        }
        process_in_queue = true;
    }
    else
    {
        flag_pos_clk = false;
    }
    if (hif_a2t_data.rst != rst_old)
    {
        rst_old = hif_a2t_data.rst;
        if (hif_a2t_data.rst == true)
        {
            flag_pos_rst = true;
        }
        else
        {
            flag_pos_rst = false;
        }
        process_in_queue = true;
    }
    else
    {
        flag_pos_rst = false;
    }
    start_old = hif_a2t_data.start;
    in_old = hif_a2t_data.in;
}


void sqrt_calculator::update_event_queue()
{
    process_in_queue = false;
    guess = guess_new;
    iter = iter_new;
    num = num_new;
}


void sqrt_calculator::flag_elaboration()
{
    flag_process_executed = false;
    if (flag_pos_clk || flag_pos_rst)
    {
        process();
        flag_process_executed = true;
    }
}


void sqrt_calculator::synch_elaboration()
{
    update_input_queue( true );
    flag_elaboration();
    flag_pos_clk = false;
    flag_pos_rst = false;
    update_event_queue();
}


void sqrt_calculator::simulate( sqrt_calculator_iostruct * io_exchange, int32_t
     & cycles_number )
{
    hif_a2t_data.clk = io_exchange->clk;
    hif_a2t_data.rst = io_exchange->rst;
    hif_a2t_data.start = io_exchange->start;
    hif_a2t_data.in = io_exchange->in;
    cycles_number = cycles_number + 1L;
    synch_elaboration();
    while (process_in_queue)
    {
        flag_elaboration();
        update_event_queue();
    }
    io_exchange->out = hif_a2t_data.out;
    io_exchange->error = hif_a2t_data.error;
    io_exchange->done = hif_a2t_data.done;
}


void sqrt_calculator::start_of_simulation()
{
    process();
    flag_process_executed = true;
    update_event_queue();
}


void sqrt_calculator::initialize()
{
    start_of_simulation();
}


void sqrt_calculator::finalize()
{
}




