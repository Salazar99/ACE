// /////////////////////////////////////////////////////////////////////////
// C++ code automatically generated by hif2sc
// Part of HIFSuite - Version 
// Site: www.hifsuite.com - Contact: hifsuite@edalab.it
//
// HIFSuite copyright: EDALab s.r.l. - Networked Embedded Systems
// Site: www.edalab.it - Contact: info@edalab.it
// /////////////////////////////////////////////////////////////////////////


#ifndef SQRT_NEWTON_HH
#define SQRT_NEWTON_HH

#include <cmath>
#include <cstddef>
#include <stdint.h>
#include "hif_globals.hpp"
#include "muffin/FaultNode.hpp"
#include "muffin/muffin_dataTypes.hpp"

class sqrt_newton
{

public:

    muffin::FaultNode hif_fault_node;
    int32_t x_old;
    bool start_old;
    bool rst_old;
    bool clk_old;
    struct sqrt_newton_iostruct{
        bool clk;
        bool rst;
        bool start;
        int32_t x;
        uint32_t y;
        bool done;
        bool error;

        sqrt_newton_iostruct():
            clk(false),
            rst(false),
            start(false),
            x(0L),
            y(0UL),
            done(false),
            error(false)
        {}

        sqrt_newton_iostruct( const bool clk_0, const bool rst_0, const bool start_0,
             const int32_t x_0, const uint32_t y_0, const bool done_0, const bool
             error_0 ):
            clk(clk_0),
            rst(rst_0),
            start(start_0),
            x(x_0),
            y(y_0),
            done(done_0),
            error(error_0)
        {}

        ~sqrt_newton_iostruct()
        {}

        bool operator == (const sqrt_newton_iostruct & other) const
        {
            if (clk != other.clk) return false;
            if (rst != other.rst) return false;
            if (start != other.start) return false;
            if (x != other.x) return false;
            if (y != other.y) return false;
            if (done != other.done) return false;
            if (error != other.error) return false;
            return true;
        }
    };
    sqrt_newton_iostruct hif_a2t_data;
    uint32_t xn;
    uint8_t iter;
    bool running;
    sqrt_newton();


    ~sqrt_newton();


    uint32_t xn_new;
    uint8_t iter_new;
    bool running_new;
    bool process_in_queue;
    bool flag_process_executed;
    bool flag_pos_clk;
    bool flag_pos_rst;

    void process();


    void update_input_queue( bool synch_phase = true );


    void update_event_queue();


    void flag_elaboration();


    void synch_elaboration();


    void simulate( sqrt_newton_iostruct * io_exchange, int32_t & cycles_number 
        );


    void start_of_simulation();


    void initialize();


    void finalize();


private:

    sqrt_newton( const sqrt_newton & );
    const sqrt_newton& operator= ( const sqrt_newton & );


};


#endif

