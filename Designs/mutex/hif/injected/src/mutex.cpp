// /////////////////////////////////////////////////////////////////////////
// C++ code automatically generated by hif2sc
// Part of HIFSuite - Version 
// Site: www.hifsuite.com - Contact: hifsuite@edalab.it
//
// HIFSuite copyright: EDALab s.r.l. - Networked Embedded Systems
// Site: www.edalab.it - Contact: info@edalab.it
// /////////////////////////////////////////////////////////////////////////


#include "../inc/mutex.hpp"



mutex::mutex() :
    hif_fault_node(muffin::hif_next_instance_counter(), 23ULL),
    in_old(uint16_t(0U)),
    clk_old(false),
    hif_a2t_data(
    false,
    uint16_t(0U),
    false,
    false),
    process_in_queue(false),
    flag_pos_clk(false)
{
    if (hif_fault_list_root != nullptr)
    {
        hif_fault_list_root->prev = &hif_fault_node;
        hif_fault_node.next = hif_fault_list_root;
    }
    hif_fault_list_root = &hif_fault_node;
}


mutex::~mutex()
{}


void mutex::process()
{
    if (muffin::inject_renamed_3( hif_fault_node.instance, 0ULL, 16ULL, static_cast<
             uint16_t >( static_cast< uint16_t >( hif_a2t_data.in >> uint16_t(15U
            ) ) & uint16_t(1U) ) ))
    {
        hif_a2t_data.positive_flag = muffin::inject( hif_fault_node.instance, 16ULL,
                 1ULL, false );
        hif_a2t_data.negative_flag = muffin::inject( hif_fault_node.instance, 17ULL,
                 1ULL, true );
    }
    else if (muffin::inject( hif_fault_node.instance, 18ULL, 1ULL, hif_a2t_data.in
             == uint16_t(0U) ))
    {
        hif_a2t_data.positive_flag = muffin::inject( hif_fault_node.instance, 19ULL,
                 1ULL, false );
        hif_a2t_data.negative_flag = muffin::inject( hif_fault_node.instance, 20ULL,
                 1ULL, false );
    }
    else
    {
        hif_a2t_data.positive_flag = muffin::inject( hif_fault_node.instance, 21ULL,
                 1ULL, true );
        hif_a2t_data.negative_flag = muffin::inject( hif_fault_node.instance, 22ULL,
                 1ULL, false );
    }
}


void mutex::update_input_queue( bool synch_phase )
{
    process_in_queue = false;
    if (hif_a2t_data.clk != clk_old)
    {
        clk_old = hif_a2t_data.clk;
        if (hif_a2t_data.clk == true)
        {
            flag_pos_clk = true;
        }
        else
        {
            flag_pos_clk = false;
        }
        process_in_queue = true;
    }
    else
    {
        flag_pos_clk = false;
    }
    in_old = hif_a2t_data.in;
}


void mutex::update_event_queue()
{
    process_in_queue = false;
}


void mutex::flag_elaboration()
{
    if (flag_pos_clk)
    {
        process();
    }
}


void mutex::synch_elaboration()
{
    update_input_queue( true );
    flag_elaboration();
    flag_pos_clk = false;
    update_event_queue();
}


void mutex::simulate( mutex_iostruct * io_exchange, int32_t & cycles_number )
{
    hif_a2t_data.clk = io_exchange->clk;
    hif_a2t_data.in = io_exchange->in;
    cycles_number = cycles_number + 1L;
    synch_elaboration();
    while (process_in_queue)
    {
        flag_elaboration();
        update_event_queue();
    }
    io_exchange->positive_flag = hif_a2t_data.positive_flag;
    io_exchange->negative_flag = hif_a2t_data.negative_flag;
}


void mutex::start_of_simulation()
{
    process();
    update_event_queue();
}


void mutex::initialize()
{
    start_of_simulation();
}


void mutex::finalize()
{
}




